import { useState, useMemo, useEffect, type ReactNode, useRef } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { Components } from 'react-markdown';
import { TextInput } from '../components/text-input/text-input';
import { Icon } from '../components/icon/icon';
import { Breadcrumbs } from '../components/breadcrumbs/breadcrumbs';
import { Button } from '../components/button/button';
import { Dropdown } from '../components/dropdown/Dropdown';
import type { DropdownOption } from '../components/dropdown/types';
import { PageWithSidebar } from '../components/layout/page-with-sidebar';
import { Overlay } from '../components/overlay/Overlay';
import pkg from '../../package.json';
import versionManifest from '@/data/doc-versions.json';
import navManifest from '@/data/nav-manifest.json';

interface DocumentationProps {
    styleMap: Record<string, string>;
}

interface SearchResult {
    path: string;
    title: string;
    snippet: string;
}

// In a real app, this would be generated by scanning the file system or from an API.
// For now, we assume only 'latest' exists based on the current repo state.
const versions: DropdownOption[] = [
    { value: 'latest', label: `v${pkg.version} (latest)` },
    ...versionManifest.map((v: { version: string; hasDocs: boolean; }) => ({
        value: v.version,
        label: `v${v.version}`,
        disabled: !v.hasDocs,
        disabledReason: "No documentation changes in this version."
    }))
];

// This uses Vite's import.meta.glob to statically analyze the imports
const docModules = import.meta.glob('/docs/**/*.md', { query: '?raw', import: 'default', eager: true });

function getDocContent(slug: string): string | null {
    const pathWithExt = `/docs/${slug}.md`;
    if (docModules[pathWithExt]) {
        return docModules[pathWithExt] as string;
    }
    const rootPath = `/docs/${slug}/_.md`;
    if (docModules[rootPath]) {
        return docModules[rootPath] as string;
    }
    return null;
}

interface NavItemData {
    title: string;
    path?: string;
    children?: NavItemData[];
}

interface NavItemProps {
    item: NavItemData;
    currentSlug: string;
    styleMap: Record<string, string>;
}

function NavItem({ item, currentSlug, styleMap }: NavItemProps) {
    const isFolder = !!item.children;
    const docRoute = useMemo(() => item.path?.replace(/\/?_\.md$/, '').replace(/\.md$/, ''), [item.path]);
    const isActive = docRoute === currentSlug;

    const isAncestor = useMemo(() => {
        if (!isFolder || !docRoute) return false;
        return currentSlug.startsWith(`${docRoute}/`);
    }, [isFolder, docRoute, currentSlug]);

    const [isOpen, setIsOpen] = useState(isActive || isAncestor);

    useEffect(() => {
        setIsOpen(isActive || isAncestor);
    }, [isActive, isAncestor]);


    if (isFolder) {
        return (
            <div className="my-1">
                <div
                    className={`flex items-center justify-between p-2 rounded-md transition-[background-color] duration-200 ease-in-out ${isActive ? 'bg-content-primary text-background-default font-semibold' : 'text-content-primary hover:bg-background-default'}`}
                >
                    {docRoute ? (
                        <Link to={`/docs/${docRoute}`} className="flex-1 font-semibold text-current">
                            {item.title}
                        </Link>
                    ) : (
                        <span className="flex-1 font-semibold">
                            {item.title}
                        </span>
                    )}
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className="p-1 -m-1 rounded-sm focus:outline-none focus:ring-2 focus:ring-interactive-accentfocus"
                        aria-label={`Toggle ${item.title} section`}
                    >
                        <Icon name="chevron" size={16} className={`transform transition-transform duration-300 ease-in-out ${isOpen ? 'rotate-180' : 'rotate-0'}`} />
                    </button>
                </div>

                <div
                    className={`grid pl-4 border-l-2 transition-[grid-template-rows] duration-300 ease-in-out ${isOpen ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'}`}
                    style={{ borderColor: styleMap.border_default }}
                >
                    <div className="overflow-hidden">
                        <div className="pt-1">
                            {item.children && item.children.map(child => (
                                <NavItem key={child.path || child.title} item={child} currentSlug={currentSlug} styleMap={styleMap} />
                            ))}
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <Link
            to={`/docs/${docRoute}`}
            className={`block p-2 my-1 rounded-md text-sm transition-[background-color] duration-200 ease-in-out ${isActive ? 'bg-content-primary text-background-default font-semibold' : 'text-content-primary hover:bg-background-default'}`}
        >
            {item.title}
        </Link>
    );
}

interface TocItem {
    level: number;
    text: string;
    id: string;
}

export function Documentation({ styleMap }: DocumentationProps) {
    const params = useParams();
    const navigate = useNavigate();

    const { version, docSlug } = useMemo(() => {
        const pathParts = params['*']?.split('/').filter(p => p) || [];

        if (pathParts[0] === 'version' && pathParts.length > 2) {
            // URL is /docs/version/1_0_11/some-page
            return {
                version: pathParts[1].replace(/_/g, '.'),
                docSlug: pathParts.slice(2).join('/')
            };
        }

        // URL is /docs/some-page or /docs/
        return {
            version: 'latest',
            docSlug: params['*'] || '_'
        };
    }, [params]);

    const [searchTerm, setSearchTerm] = useState('');
    const [selectedVersion, setSelectedVersion] = useState(version);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [docContent, setDocContent] = useState('');
    const [toc, setToc] = useState<TocItem[]>([]);
    const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
    const [isSearchOverlayOpen, setIsSearchOverlayOpen] = useState(false);
    const searchInputContainerRef = useRef<HTMLDivElement>(null);

    const docPath = useMemo(() => {
        if (version === 'latest') {
            return docSlug;
        }
        return `version/${version.replace(/\./g, '_')}/${docSlug}`;
    }, [version, docSlug]);

    const docStructure: NavItemData[] = navManifest;

    const markdownComponents: Components = {
        h1: ({ ...props }) => <h1 className="text-4xl font-bold mb-6" style={{ color: styleMap.content_primary }} {...props} />,
        h2: ({ ...props }) => <h2 className="text-2xl font-bold mt-8 mb-4 border-b pb-2" style={{ color: styleMap.content_primary, borderColor: styleMap.border_default }} {...props} />,
        h3: ({ ...props }) => <h3 className="text-xl font-semibold mt-6 mb-3" style={{ color: styleMap.content_primary }} {...props} />,
        p: ({ ...props }) => <p className="mb-4 leading-relaxed" style={{ color: styleMap.text_light }} {...props} />,
        ul: ({ ...props }) => <ul className="list-disc list-outside pl-6 mb-4 space-y-2" style={{ color: styleMap.text_light }} {...props} />,
        ol: ({ ...props }) => <ol className="list-decimal list-outside pl-6 mb-4 space-y-2" style={{ color: styleMap.text_light }} {...props} />,
        li: ({ ...props }) => <li className="mb-2" {...props} />,
        code: (props) => {
            const { inline, className, children, ...rest } = props as { inline?: boolean; className?: string; children?: ReactNode };
            const match = /language-(\w+)/.exec(className || '');
            return !inline && match ? (
                <div className="my-4 rounded-lg bg-surface-default overflow-hidden border" style={{ borderColor: styleMap.border_default }}>
                    <pre className="p-4 text-sm overflow-x-auto"><code {...rest} className={className}>{children}</code></pre>
                </div>
            ) : (
                <code {...rest} className={`px-1.5 py-1 rounded text-sm bg-surface-default ${className || ''}`}>{children}</code>
            );
        },
        pre: ({ children }) => <>{children}</>,
        a: ({ ...props }) => <a className="text-interactive-accentfocus hover:underline" {...props} />,
        strong: ({ ...props }) => <strong className="font-bold text-content-primary" {...props} />,
        blockquote: ({ ...props }) => <blockquote className="border-l-4 pl-4 my-4 italic" style={{ borderColor: styleMap.interactive_accentfocus, color: styleMap.content_secondary }} {...props} />,
    };

    useEffect(() => {
        const content = getDocContent(docPath);
        if (content) {
            setDocContent(content);
            const headings = content.match(/^#{1,3}\s+(.+)$/gm) || [];
            const newToc: TocItem[] = headings.map(heading => {
                const level = heading.match(/^#+/)?.[0].length || 1;
                const text = heading.replace(/^#+\s+/, '');
                const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                return { level, text, id };
            });
            setToc(newToc);
        } else {
            setDocContent(`## Page Not Found

The document at \`${docPath}\` could not be found.`);
            setToc([]);
        }
    }, [docPath]);

    useEffect(() => {
        setSelectedVersion(version);
    }, [version]);

    useEffect(() => {
        if (searchTerm.trim().length < 2) {
            setSearchResults([]);
            setIsSearchOverlayOpen(false);
            return;
        }

        const results: SearchResult[] = [];
        const searchRegex = new RegExp(searchTerm.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');

        for (const path in docModules) {
            const content = docModules[path] as string;

            const matches = [...content.matchAll(searchRegex)];
            if (matches.length === 0) continue;

            const titleMatch = content.match(/^#\s+(.+)$/m);
            const docPath = path.replace('/docs/', '').replace(/\.md$/, '').replace(/\/_\/?$/, '');
            const title = titleMatch ? titleMatch[1] : docPath.split('/').pop() || docPath;

            for (const match of matches) {
                if (match.index === undefined) continue;

                const snippetStart = Math.max(0, match.index - 50);
                const snippetEnd = Math.min(content.length, match.index + searchTerm.length + 50);
                let snippet = content.substring(snippetStart, snippetEnd);

                snippet = snippet.replace(searchRegex, (m) => `<strong class="text-interactive-accentfocus bg-transparent">${m}</strong>`);

                snippet = (snippetStart > 0 ? '...' : '') + snippet + (snippetEnd < content.length ? '...' : '');

                results.push({
                    path: docPath,
                    title,
                    snippet,
                });
            }
        }

        const uniqueResults = results.filter((result, index, self) =>
            index === self.findIndex((r) => r.path === result.path && r.snippet === result.snippet)
        );

        setSearchResults(uniqueResults.slice(0, 20));
        setIsSearchOverlayOpen(uniqueResults.length > 0);
    }, [searchTerm]);

    const breadcrumbs = useMemo(() => {
        const items = [{ label: 'Docs', href: '/docs' }];
        let currentUrl = '/docs';

        if (version !== 'latest') {
            const versionPath = `version/${version.replace(/\./g, '_')}`;
            currentUrl += `/${versionPath}`;
            items.push({ label: `v${version}`, href: currentUrl });
        }

        const slugParts = docSlug.replace(/_$/, '').split('/').filter(p => p);

        for (const part of slugParts) {
            currentUrl += `/${part}`;
            items.push({ label: part.replace(/-/g, ' '), href: currentUrl });
        }
        return items;
    }, [docSlug, version]);

    const githubEditUrl = useMemo(() => {
        let editPath = `/docs/${docPath}.md`;
        if (!docModules[editPath]) {
            editPath = `/docs/${docPath}/_.md`;
        }
        return `https://github.com/gwenphalan/borg-ui/blob/main${editPath}`;
    }, [docPath]);

    const handleVersionChange = (newVersionValue: string | string[]) => {
        if (typeof newVersionValue === 'string' && newVersionValue !== selectedVersion) {
            setSelectedVersion(newVersionValue);
            if (newVersionValue === 'latest') {
                navigate(`/docs/${docSlug}`);
            } else {
                const versionPath = newVersionValue.replace(/\./g, '_');
                navigate(`/docs/version/${versionPath}/${docSlug}`);
            }
        }
    }

    const toolbarLeftContent = (
        <Breadcrumbs items={breadcrumbs} />
    );

    const toolbarRightContent = (
        <Button
            variant="outline-primary"
            size="sm"
            onClick={() => window.open(githubEditUrl, '_blank')}
        >
            Edit on GitHub
        </Button>
    );

    const sidebarContent = (
        <>
            <div className="mb-4">
                <Dropdown
                    options={versions}
                    value={selectedVersion}
                    onChange={handleVersionChange}
                    isOpen={isDropdownOpen}
                    onOpenChange={setIsDropdownOpen}
                />
            </div>

            <div ref={searchInputContainerRef} className="relative mb-4">
                <TextInput
                    value={searchTerm}
                    onChange={setSearchTerm}
                    placeholder="Search..."
                    type="search"
                    isClearable
                    onFocus={() => {
                        if (searchResults.length > 0) {
                            setIsSearchOverlayOpen(true);
                        }
                    }}
                />
                <Overlay
                    reference={searchInputContainerRef.current}
                    open={isSearchOverlayOpen}
                    onOpenChange={setIsSearchOverlayOpen}
                    placement="bottom-start"
                    matchWidth
                    offsetPx={4}
                    className="z-50"
                >
                    <div className="dropdown-base max-h-96 overflow-y-auto">
                        {searchResults.map((result, index) => (
                            <Link
                                key={`${result.path}-${index}`}
                                to={`/docs/${result.path}`}
                                className="block p-2 text-sm hover:bg-background-default rounded-md"
                                onClick={() => {
                                    setIsSearchOverlayOpen(false);
                                }}
                            >
                                <div className="font-bold text-content-primary truncate">{result.title}</div>
                                <div className="text-content-secondary text-xs" dangerouslySetInnerHTML={{ __html: result.snippet }} />
                            </Link>
                        ))}
                    </div>
                </Overlay>
            </div>

            <nav className="flex-1 space-y-1">
                {docStructure.map(item => (
                    <NavItem key={item.path || item.title} item={item} currentSlug={docSlug} styleMap={styleMap} />
                ))}
            </nav>
        </>
    );

    return (
        <PageWithSidebar
            sidebarContent={sidebarContent}
            toolbarLeftContent={toolbarLeftContent}
            toolbarRightContent={toolbarRightContent}
        >
            <div className="flex gap-8 overflow-auto h-full">
                <article className="flex-1 prose prose-invert max-w-none">
                    <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={markdownComponents}
                    >
                        {docContent}
                    </ReactMarkdown>
                </article>

                {toc.length > 0 && (
                    <aside className="w-56 hidden xl:block flex-shrink-0">
                        <div className="">
                            <h3 className="text-sm font-semibold mb-3 uppercase tracking-wider" style={{ color: styleMap.content_secondary }}>
                                On this page
                            </h3>
                            <nav>
                                <ul className="space-y-2">
                                    {toc.map((item) => (
                                        <li key={item.id} style={{ paddingLeft: `${(item.level - 1) * 0.75}rem` }}>
                                            <a
                                                href={`#${item.id}`}
                                                className="text-sm block hover:text-content-primary transition-colors"
                                                style={{ color: styleMap.content_secondary }}
                                            >
                                                {item.text}
                                            </a>
                                        </li>
                                    ))}
                                </ul>
                            </nav>
                        </div>
                    </aside>
                )}
            </div>
        </PageWithSidebar>
    );
}